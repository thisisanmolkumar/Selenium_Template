/*
 * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { ContentChildren, Directive } from '@angular/core';
import { DatagridCellRenderer } from './cell-renderer';
import * as i0 from "@angular/core";
import * as i1 from "../providers/columns.service";
export class DatagridRowRenderer {
    constructor(columnsService) {
        this.columnsService = columnsService;
        this.subscriptions = [];
    }
    ngAfterContentInit() {
        this.setColumnState(); // case #3 and #4
        this.subscriptions.push(this.cells.changes.subscribe(() => {
            this.setColumnState(); // case #2
            // Note on case #2: In the case of dynamic columns, when one column (header/cell together) gets deleted,
            // this.cells.changes emits before this.columnsService.columns gets updated in MainRenderer
            // when this.headers.changes emits as well. So that means there will be n+1 column state providers
            // when this.cells.changes emits. Hence, we should quit earlier there. But this method will be called
            // right after again when this.headers.changes emits. By then, there will be the same number of column state
            // providers as column headers.
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    setColumnState() {
        // This method runs in four cases:
        // 1. When the initial rows appear on the first page.
        //    In this case, the method will be called in DatagridMainRenderer.
        // 2. When columns (corresponding header/cells) get added and deleted.
        //    In this case, the method will be called in DatagridMainRenderer. (Read the note on this case above).
        // 3. When rows load asynchronously.
        //    In this case, the method will be called in this class.
        // 4. When rows load after switching pages.
        //    In this case, the method will be called in this class (Basically, same as the case 3).
        if (this.cells.length === this.columnsService.columns.length) {
            this.cells.forEach((cell, index) => {
                if (this.columnsService.columns[index]) {
                    cell.columnState = this.columnsService.columns[index];
                }
            });
        }
    }
}
DatagridRowRenderer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: DatagridRowRenderer, deps: [{ token: i1.ColumnsService }], target: i0.ɵɵFactoryTarget.Directive });
DatagridRowRenderer.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: DatagridRowRenderer, selector: "clr-dg-row, clr-dg-row-detail", queries: [{ propertyName: "cells", predicate: DatagridCellRenderer }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: DatagridRowRenderer, decorators: [{
            type: Directive,
            args: [{
                    selector: 'clr-dg-row, clr-dg-row-detail',
                }]
        }], ctorParameters: function () { return [{ type: i1.ColumnsService }]; }, propDecorators: { cells: [{
                type: ContentChildren,
                args: [DatagridCellRenderer]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LXJlbmRlcmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvcm93LXJlbmRlcmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFFSCxPQUFPLEVBQW9CLGVBQWUsRUFBRSxTQUFTLEVBQXdCLE1BQU0sZUFBZSxDQUFDO0FBSW5HLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFLdkQsTUFBTSxPQUFPLG1CQUFtQjtJQUc5QixZQUFvQixjQUE4QjtRQUE5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFpQjFDLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztJQWpCVSxDQUFDO0lBRXRELGtCQUFrQjtRQUNoQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxpQkFBaUI7UUFDeEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsVUFBVTtZQUNqQyx3R0FBd0c7WUFDeEcsMkZBQTJGO1lBQzNGLGtHQUFrRztZQUNsRyxxR0FBcUc7WUFDckcsNEdBQTRHO1lBQzVHLCtCQUErQjtRQUNqQyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUlELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFTSxjQUFjO1FBQ25CLGtDQUFrQztRQUNsQyxxREFBcUQ7UUFDckQsc0VBQXNFO1FBQ3RFLHNFQUFzRTtRQUN0RSwwR0FBMEc7UUFDMUcsb0NBQW9DO1FBQ3BDLDREQUE0RDtRQUM1RCwyQ0FBMkM7UUFDM0MsNEZBQTRGO1FBQzVGLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQzVELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUNqQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUN0QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUN2RDtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDOztnSEEzQ1UsbUJBQW1CO29HQUFuQixtQkFBbUIsMkZBQ2Isb0JBQW9COzJGQUQxQixtQkFBbUI7a0JBSC9CLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLCtCQUErQjtpQkFDMUM7cUdBRWdELEtBQUs7c0JBQW5ELGVBQWU7dUJBQUMsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIyIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDb2x1bW5zU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9jb2x1bW5zLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRDZWxsUmVuZGVyZXIgfSBmcm9tICcuL2NlbGwtcmVuZGVyZXInO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93LCBjbHItZGctcm93LWRldGFpbCcsXG59KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkUm93UmVuZGVyZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBAQ29udGVudENoaWxkcmVuKERhdGFncmlkQ2VsbFJlbmRlcmVyKSBwcml2YXRlIGNlbGxzOiBRdWVyeUxpc3Q8RGF0YWdyaWRDZWxsUmVuZGVyZXI+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29sdW1uc1NlcnZpY2U6IENvbHVtbnNTZXJ2aWNlKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLnNldENvbHVtblN0YXRlKCk7IC8vIGNhc2UgIzMgYW5kICM0XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmNlbGxzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRDb2x1bW5TdGF0ZSgpOyAvLyBjYXNlICMyXG4gICAgICAgIC8vIE5vdGUgb24gY2FzZSAjMjogSW4gdGhlIGNhc2Ugb2YgZHluYW1pYyBjb2x1bW5zLCB3aGVuIG9uZSBjb2x1bW4gKGhlYWRlci9jZWxsIHRvZ2V0aGVyKSBnZXRzIGRlbGV0ZWQsXG4gICAgICAgIC8vIHRoaXMuY2VsbHMuY2hhbmdlcyBlbWl0cyBiZWZvcmUgdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zIGdldHMgdXBkYXRlZCBpbiBNYWluUmVuZGVyZXJcbiAgICAgICAgLy8gd2hlbiB0aGlzLmhlYWRlcnMuY2hhbmdlcyBlbWl0cyBhcyB3ZWxsLiBTbyB0aGF0IG1lYW5zIHRoZXJlIHdpbGwgYmUgbisxIGNvbHVtbiBzdGF0ZSBwcm92aWRlcnNcbiAgICAgICAgLy8gd2hlbiB0aGlzLmNlbGxzLmNoYW5nZXMgZW1pdHMuIEhlbmNlLCB3ZSBzaG91bGQgcXVpdCBlYXJsaWVyIHRoZXJlLiBCdXQgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWRcbiAgICAgICAgLy8gcmlnaHQgYWZ0ZXIgYWdhaW4gd2hlbiB0aGlzLmhlYWRlcnMuY2hhbmdlcyBlbWl0cy4gQnkgdGhlbiwgdGhlcmUgd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgY29sdW1uIHN0YXRlXG4gICAgICAgIC8vIHByb3ZpZGVycyBhcyBjb2x1bW4gaGVhZGVycy5cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHVibGljIHNldENvbHVtblN0YXRlKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIHJ1bnMgaW4gZm91ciBjYXNlczpcbiAgICAvLyAxLiBXaGVuIHRoZSBpbml0aWFsIHJvd3MgYXBwZWFyIG9uIHRoZSBmaXJzdCBwYWdlLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBpbiBEYXRhZ3JpZE1haW5SZW5kZXJlci5cbiAgICAvLyAyLiBXaGVuIGNvbHVtbnMgKGNvcnJlc3BvbmRpbmcgaGVhZGVyL2NlbGxzKSBnZXQgYWRkZWQgYW5kIGRlbGV0ZWQuXG4gICAgLy8gICAgSW4gdGhpcyBjYXNlLCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGluIERhdGFncmlkTWFpblJlbmRlcmVyLiAoUmVhZCB0aGUgbm90ZSBvbiB0aGlzIGNhc2UgYWJvdmUpLlxuICAgIC8vIDMuIFdoZW4gcm93cyBsb2FkIGFzeW5jaHJvbm91c2x5LlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBpbiB0aGlzIGNsYXNzLlxuICAgIC8vIDQuIFdoZW4gcm93cyBsb2FkIGFmdGVyIHN3aXRjaGluZyBwYWdlcy5cbiAgICAvLyAgICBJbiB0aGlzIGNhc2UsIHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgaW4gdGhpcyBjbGFzcyAoQmFzaWNhbGx5LCBzYW1lIGFzIHRoZSBjYXNlIDMpLlxuICAgIGlmICh0aGlzLmNlbGxzLmxlbmd0aCA9PT0gdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zW2luZGV4XSkge1xuICAgICAgICAgIGNlbGwuY29sdW1uU3RhdGUgPSB0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==