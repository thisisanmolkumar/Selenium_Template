/*
 * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { animate, state, style, transition, trigger } from '@angular/animations';
import { isPlatformBrowser } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, PLATFORM_ID, Self, SkipSelf, ViewChild, } from '@angular/core';
import { Subject } from 'rxjs';
import { debounceTime, filter } from 'rxjs/operators';
import { IfExpandService } from '../../utils/conditional/if-expanded.service';
import { KeyCodes } from '../../utils/enums/key-codes.enum';
import { isKeyEitherLetterOrNumber, keyValidator, preventArrowKeyScroll } from '../../utils/focus/key-focus/util';
import { UNIQUE_ID, UNIQUE_ID_PROVIDER } from '../../utils/id-generator/id-generator.service';
import { LoadingListener } from '../../utils/loading/loading-listener';
import { DeclarativeTreeNodeModel } from './models/declarative-tree-node.model';
import { ClrSelectedState } from './models/selected-state.enum';
import { TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNodeLink } from './tree-node-link';
import * as i0 from "@angular/core";
import * as i1 from "../../utils/for-type-ahead/for-type-ahead.service";
import * as i2 from "./tree-features.service";
import * as i3 from "../../utils/conditional/if-expanded.service";
import * as i4 from "../../utils/i18n/common-strings.service";
import * as i5 from "./tree-focus-manager.service";
import * as i6 from "./recursive-children";
import * as i7 from "@angular/common";
import * as i8 from "../../icon/icon";
const LVIEW_CONTEXT_INDEX = 8;
// If the user types multiple keys without allowing 200ms to pass between them,
// then those keys are sent together in one request.
const TREE_TYPE_AHEAD_TIMEOUT = 200;
export class ClrTreeNode {
    constructor(nodeId, platformId, parent, forTypeAheadProvider, featuresService, expandService, commonStrings, focusManager, injector) {
        this.nodeId = nodeId;
        this.platformId = platformId;
        this.forTypeAheadProvider = forTypeAheadProvider;
        this.featuresService = featuresService;
        this.expandService = expandService;
        this.commonStrings = commonStrings;
        this.focusManager = focusManager;
        this.STATES = ClrSelectedState;
        this.skipEmitChange = false;
        this.isModelLoading = false;
        this.typeAheadKeyEvent = new Subject();
        this.typeAheadKeyBuffer = '';
        this.selectedChange = new EventEmitter(false);
        this.expandedChange = new EventEmitter();
        this.subscriptions = [];
        this.contentContainerTabindex = -1;
        if (this.featuresService.recursion) {
            // I'm completely stuck, we have to hack into private properties until either
            // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
            // are fixed
            // This is for non-ivy implementations
            if (injector.view) {
                this._model = injector.view.context.clrModel;
            }
            else {
                // Ivy puts this on a specific index of a _lView property
                this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
            }
        }
        else {
            // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
            this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
        }
        this._model.nodeId = this.nodeId;
    }
    isExpandable() {
        if (typeof this.expandable !== 'undefined') {
            return this.expandable;
        }
        return !!this.expandService.expandable || this.isParent;
    }
    isSelectable() {
        return this.featuresService.selectable;
    }
    get selected() {
        return this._model.selected.value;
    }
    set selected(value) {
        this.featuresService.selectable = true;
        // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
        // This shouldn't happen with strict typing on the app's side, but it's not up to us.
        if (value === null || typeof value === 'undefined') {
            value = ClrSelectedState.UNSELECTED;
        }
        // We match booleans to the corresponding ClrSelectedState
        if (typeof value === 'boolean') {
            value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
        }
        // We propagate only if the tree is in smart mode, and skip emitting the output when we set the input
        // See https://github.com/vmware/clarity/issues/3073
        this.skipEmitChange = true;
        this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
        this.skipEmitChange = false;
    }
    get ariaSelected() {
        return this.isSelectable() ? this._model.selected.value === ClrSelectedState.SELECTED : null;
    }
    // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
    // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
    // case, you can't use a structural directive, it would need to go on an ng-container.
    get expanded() {
        return this.expandService.expanded;
    }
    set expanded(value) {
        this.expandService.expanded = value;
    }
    ngOnInit() {
        this._model.expanded = this.expanded;
        this.subscriptions.push(this._model.selected.pipe(filter(() => !this.skipEmitChange)).subscribe(value => {
            this.selectedChange.emit(value);
        }));
        this.subscriptions.push(this.expandService.expandChange.subscribe(value => {
            this.expandedChange.emit(value);
            this._model.expanded = value;
        }));
        this.subscriptions.push(this.focusManager.focusRequest.subscribe(nodeId => {
            if (this.nodeId === nodeId) {
                this.focusTreeNode();
            }
        }), this.focusManager.focusChange.subscribe(nodeId => {
            this.checkTabIndex(nodeId);
        }));
        this.subscriptions.push(this._model.loading$.pipe(debounceTime(0)).subscribe(isLoading => (this.isModelLoading = isLoading)));
    }
    ngAfterContentInit() {
        if (this.forTypeAheadProvider) {
            this._model.textContent = this.forTypeAheadProvider.textContent;
            this.subscriptions.push(this.typeAheadKeyEvent.pipe(debounceTime(TREE_TYPE_AHEAD_TIMEOUT)).subscribe((bufferedKeys) => {
                this.focusManager.focusNodeStartsWith(bufferedKeys, this._model);
                // reset once bufferedKeys are used
                this.typeAheadKeyBuffer = '';
            }));
        }
    }
    ngOnDestroy() {
        this._model.destroy();
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    get treeNodeLink() {
        return this.treeNodeLinkList && this.treeNodeLinkList.first;
    }
    setTabIndex(value) {
        this.contentContainerTabindex = value;
        this.contentContainer.nativeElement.setAttribute('tabindex', value);
    }
    checkTabIndex(nodeId) {
        if (isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
            this.setTabIndex(-1);
        }
    }
    focusTreeNode() {
        const containerEl = this.contentContainer.nativeElement;
        if (isPlatformBrowser(this.platformId) && document.activeElement !== containerEl) {
            this.setTabIndex(0);
            containerEl.focus();
            containerEl.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
    }
    broadcastFocusOnContainer() {
        this.focusManager.broadcastFocusedNode(this.nodeId);
    }
    onKeyDown(event) {
        // Two reasons to prevent default behavior:
        // 1. to prevent scrolling on arrow keys
        // 2. Assistive Technology focus differs from Keyboard focus behavior.
        //    By default, pressing arrow key makes AT focus go into the nested content of the item.
        preventArrowKeyScroll(event);
        // https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-22
        switch (keyValidator(event.key)) {
            case KeyCodes.ArrowUp:
                this.focusManager.focusNodeAbove(this._model);
                break;
            case KeyCodes.ArrowDown:
                this.focusManager.focusNodeBelow(this._model);
                break;
            case KeyCodes.ArrowRight:
                this.expandOrFocusFirstChild();
                break;
            case KeyCodes.ArrowLeft:
                this.collapseOrFocusParent();
                break;
            case KeyCodes.Home:
                event.preventDefault();
                this.focusManager.focusFirstVisibleNode();
                break;
            case KeyCodes.End:
                event.preventDefault();
                this.focusManager.focusLastVisibleNode();
                break;
            case KeyCodes.Enter:
                this.toggleExpandOrTriggerDefault();
                break;
            case KeyCodes.Space:
            case KeyCodes.Spacebar:
                // to prevent scrolling on space key in this specific case
                event.preventDefault();
                this.toggleExpandOrTriggerDefault();
                break;
            default:
                if (this._model.textContent && isKeyEitherLetterOrNumber(event)) {
                    this.typeAheadKeyBuffer += event.key;
                    this.typeAheadKeyEvent.next(this.typeAheadKeyBuffer);
                    return;
                }
                break;
        }
        // if non-letter keys are pressed, do reset.
        this.typeAheadKeyBuffer = '';
    }
    get isParent() {
        return this._model.children && this._model.children.length > 0;
    }
    toggleExpandOrTriggerDefault() {
        if (this.isExpandable() && !this.isSelectable()) {
            this.expandService.expanded = !this.expanded;
        }
        else {
            this.triggerDefaultAction();
        }
    }
    expandOrFocusFirstChild() {
        if (this.expanded) {
            // if the node is already expanded and has children, focus its very first child
            if (this.isParent) {
                this.focusManager.focusNodeBelow(this._model);
            }
        }
        else {
            // we must check if the node is expandable, in order to set .expanded to true from false
            // because we shouldn't set .expanded to true if it's not expandable node
            if (this.isExpandable()) {
                this.expandService.expanded = true;
            }
        }
    }
    collapseOrFocusParent() {
        if (this.expanded) {
            this.expandService.expanded = false;
        }
        else {
            this.focusManager.focusParent(this._model);
        }
    }
    triggerDefaultAction() {
        if (this.treeNodeLink) {
            this.treeNodeLink.activate();
        }
        else {
            if (this.isSelectable()) {
                this._model.toggleSelection(this.featuresService.eager);
            }
        }
    }
}
ClrTreeNode.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: ClrTreeNode, deps: [{ token: UNIQUE_ID }, { token: PLATFORM_ID }, { token: ClrTreeNode, optional: true, skipSelf: true }, { token: i1.ForTypeAheadProvider, optional: true, self: true }, { token: i2.TreeFeaturesService }, { token: i3.IfExpandService }, { token: i4.ClrCommonStringsService }, { token: i5.TreeFocusManagerService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
ClrTreeNode.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.3", type: ClrTreeNode, selector: "clr-tree-node", inputs: { selected: ["clrSelected", "selected"], expandable: ["clrExpandable", "expandable"], expanded: ["clrExpanded", "expanded"] }, outputs: { selectedChange: "clrSelectedChange", expandedChange: "clrExpandedChange" }, host: { properties: { "class.clr-tree-node": "true" } }, providers: [
        UNIQUE_ID_PROVIDER,
        TREE_FEATURES_PROVIDER,
        IfExpandService,
        { provide: LoadingListener, useExisting: IfExpandService },
    ], queries: [{ propertyName: "treeNodeLinkList", predicate: ClrTreeNodeLink }], viewQueries: [{ propertyName: "contentContainer", first: true, predicate: ["contentContainer"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: "<!--\n  ~ Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  #contentContainer\n  role=\"treeitem\"\n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\"\n  (keydown)=\"onKeyDown($event)\"\n  (focus)=\"broadcastFocusOnContainer()\"\n>\n  <button\n    *ngIf=\"isExpandable() && !isModelLoading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\"\n    (focus)=\"focusTreeNode()\"\n  >\n    <cds-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"angle\"\n      [attr.direction]=\"expandService.expanded ? 'down' : 'right'\"\n    ></cds-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || isModelLoading\">\n    <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input\n      aria-hidden=\"true\"\n      type=\"checkbox\"\n      id=\"{{nodeId}}-check\"\n      class=\"clr-checkbox\"\n      [checked]=\"_model.selected.value === STATES.SELECTED\"\n      [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n      (change)=\"_model.toggleSelection(featuresService.eager)\"\n      (focus)=\"focusTreeNode()\"\n      tabindex=\"-1\"\n    />\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\">\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable\">\n      <span *ngIf=\"ariaSelected\">selected</span>\n      <span *ngIf=\"!ariaSelected\">unselected</span>\n    </div>\n  </div>\n</div>\n<div\n  class=\"clr-treenode-children\"\n  [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n  [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\"\n>\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n", components: [{ type: i6.RecursiveChildren, selector: "clr-recursive-children", inputs: ["parent", "children"] }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.CdsIconCustomTag, selector: "cds-icon" }], animations: [
        trigger('toggleChildrenAnim', [
            transition('collapsed => expanded', [style({ height: 0 }), animate(200, style({ height: '*' }))]),
            transition('expanded => collapsed', [style({ height: '*' }), animate(200, style({ height: 0 }))]),
            state('expanded', style({ height: '*', 'overflow-y': 'visible' })),
            state('collapsed', style({ height: 0 })),
        ]),
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: ClrTreeNode, decorators: [{
            type: Component,
            args: [{ selector: 'clr-tree-node', providers: [
                        UNIQUE_ID_PROVIDER,
                        TREE_FEATURES_PROVIDER,
                        IfExpandService,
                        { provide: LoadingListener, useExisting: IfExpandService },
                    ], animations: [
                        trigger('toggleChildrenAnim', [
                            transition('collapsed => expanded', [style({ height: 0 }), animate(200, style({ height: '*' }))]),
                            transition('expanded => collapsed', [style({ height: '*' }), animate(200, style({ height: 0 }))]),
                            state('expanded', style({ height: '*', 'overflow-y': 'visible' })),
                            state('collapsed', style({ height: 0 })),
                        ]),
                    ], host: {
                        '[class.clr-tree-node]': 'true',
                    }, template: "<!--\n  ~ Copyright (c) 2016-2021 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  #contentContainer\n  role=\"treeitem\"\n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\"\n  (keydown)=\"onKeyDown($event)\"\n  (focus)=\"broadcastFocusOnContainer()\"\n>\n  <button\n    *ngIf=\"isExpandable() && !isModelLoading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\"\n    (focus)=\"focusTreeNode()\"\n  >\n    <cds-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"angle\"\n      [attr.direction]=\"expandService.expanded ? 'down' : 'right'\"\n    ></cds-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || isModelLoading\">\n    <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input\n      aria-hidden=\"true\"\n      type=\"checkbox\"\n      id=\"{{nodeId}}-check\"\n      class=\"clr-checkbox\"\n      [checked]=\"_model.selected.value === STATES.SELECTED\"\n      [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n      (change)=\"_model.toggleSelection(featuresService.eager)\"\n      (focus)=\"focusTreeNode()\"\n      tabindex=\"-1\"\n    />\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\">\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable\">\n      <span *ngIf=\"ariaSelected\">selected</span>\n      <span *ngIf=\"!ariaSelected\">unselected</span>\n    </div>\n  </div>\n</div>\n<div\n  class=\"clr-treenode-children\"\n  [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n  [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\"\n>\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [UNIQUE_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: ClrTreeNode, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i1.ForTypeAheadProvider, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i2.TreeFeaturesService }, { type: i3.IfExpandService }, { type: i4.ClrCommonStringsService }, { type: i5.TreeFocusManagerService }, { type: i0.Injector }]; }, propDecorators: { selected: [{
                type: Input,
                args: ['clrSelected']
            }], selectedChange: [{
                type: Output,
                args: ['clrSelectedChange']
            }], expandable: [{
                type: Input,
                args: ['clrExpandable']
            }], expanded: [{
                type: Input,
                args: ['clrExpanded']
            }], expandedChange: [{
                type: Output,
                args: ['clrExpandedChange']
            }], contentContainer: [{
                type: ViewChild,
                args: ['contentContainer', { read: ElementRef, static: true }]
            }], treeNodeLinkList: [{
                type: ContentChildren,
                args: [ClrTreeNodeLink, { descendants: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUVMLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBRU4sS0FBSyxFQUdMLFFBQVEsRUFDUixNQUFNLEVBQ04sV0FBVyxFQUVYLElBQUksRUFDSixRQUFRLEVBQ1IsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUM1RCxPQUFPLEVBQUUseUJBQXlCLEVBQUUsWUFBWSxFQUFFLHFCQUFxQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFHbEgsT0FBTyxFQUFFLFNBQVMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLCtDQUErQyxDQUFDO0FBQzlGLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUN2RSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUNoRixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUVoRSxPQUFPLEVBQUUsc0JBQXNCLEVBQXVCLE1BQU0seUJBQXlCLENBQUM7QUFFdEYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7Ozs7Ozs7O0FBRW5ELE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO0FBRTlCLCtFQUErRTtBQUMvRSxvREFBb0Q7QUFDcEQsTUFBTSx1QkFBdUIsR0FBRyxHQUFHLENBQUM7QUF1QnBDLE1BQU0sT0FBTyxXQUFXO0lBU3RCLFlBQzRCLE1BQWMsRUFDWCxVQUFlLEVBRzVDLE1BQXNCLEVBQ00sb0JBQTBDLEVBQy9ELGVBQXVDLEVBQ3ZDLGFBQThCLEVBQzlCLGFBQXNDLEVBQ3JDLFlBQXdDLEVBQ2hELFFBQWtCO1FBVlEsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNYLGVBQVUsR0FBVixVQUFVLENBQUs7UUFJaEIseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFzQjtRQUMvRCxvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7UUFDdkMsa0JBQWEsR0FBYixhQUFhLENBQWlCO1FBQzlCLGtCQUFhLEdBQWIsYUFBYSxDQUF5QjtRQUNyQyxpQkFBWSxHQUFaLFlBQVksQ0FBNEI7UUFsQmxELFdBQU0sR0FBRyxnQkFBZ0IsQ0FBQztRQUNsQixtQkFBYyxHQUFHLEtBQUssQ0FBQztRQUMvQixtQkFBYyxHQUFHLEtBQUssQ0FBQztRQUVmLHNCQUFpQixHQUFvQixJQUFJLE9BQU8sRUFBVSxDQUFDO1FBRTNELHVCQUFrQixHQUFHLEVBQUUsQ0FBQztRQW9FSCxtQkFBYyxHQUFHLElBQUksWUFBWSxDQUFtQixLQUFLLENBQUMsQ0FBQztRQXFCM0QsbUJBQWMsR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO1FBRWxFLGtCQUFhLEdBQW1CLEVBQUUsQ0FBQztRQUUzQyw2QkFBd0IsR0FBRyxDQUFDLENBQUMsQ0FBQztRQTlFNUIsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRTtZQUNsQyw2RUFBNkU7WUFDN0UscUdBQXFHO1lBQ3JHLFlBQVk7WUFDWixzQ0FBc0M7WUFDdEMsSUFBSyxRQUFnQixDQUFDLElBQUksRUFBRTtnQkFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBSSxRQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDO2FBQ3ZEO2lCQUFNO2dCQUNMLHlEQUF5RDtnQkFDekQsSUFBSSxDQUFDLE1BQU0sR0FBSSxRQUFnQixDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQzthQUN0RTtTQUNGO2FBQU07WUFDTCw2RkFBNkY7WUFDN0YsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUUsTUFBTSxDQUFDLE1BQXNDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzVHO1FBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNuQyxDQUFDO0lBSUQsWUFBWTtRQUNWLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxLQUFLLFdBQVcsRUFBRTtZQUMxQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7U0FDeEI7UUFDRCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQzFELENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFDSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7SUFDcEMsQ0FBQztJQUNELElBQUksUUFBUSxDQUFDLEtBQWlDO1FBQzVDLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN2QywyR0FBMkc7UUFDM0cscUZBQXFGO1FBQ3JGLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLEVBQUU7WUFDbEQsS0FBSyxHQUFHLGdCQUFnQixDQUFDLFVBQVUsQ0FBQztTQUNyQztRQUNELDBEQUEwRDtRQUMxRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUM5QixLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQztTQUN6RTtRQUNELHFHQUFxRztRQUNyRyxvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkYsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7SUFDOUIsQ0FBQztJQUlELElBQUksWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEtBQUssZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDL0YsQ0FBQztJQU1ELHVHQUF1RztJQUN2Ryw2R0FBNkc7SUFDN0csc0ZBQXNGO0lBQ3RGLElBQ0ksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7SUFDckMsQ0FBQztJQUNELElBQUksUUFBUSxDQUFDLEtBQWM7UUFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ3RDLENBQUM7SUFVRCxRQUFRO1FBQ04sSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM5RSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FDSCxDQUFDO1FBQ0YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNoRCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUNGLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDaEQsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sRUFBRTtnQkFDMUIsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2FBQ3RCO1FBQ0gsQ0FBQyxDQUFDLEVBQ0YsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9DLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQ3JHLENBQUM7SUFDSixDQUFDO0lBRUQsa0JBQWtCO1FBQ2hCLElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQzdCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxXQUFXLENBQUM7WUFFaEUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxZQUFvQixFQUFFLEVBQUU7Z0JBQ3BHLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDakUsbUNBQW1DO2dCQUNuQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxDQUFDO1lBQy9CLENBQUMsQ0FBQyxDQUNILENBQUM7U0FDSDtJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFPRCxJQUFJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDO0lBQzlELENBQUM7SUFFTyxXQUFXLENBQUMsS0FBYTtRQUMvQixJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRU8sYUFBYSxDQUFDLE1BQWM7UUFDbEMsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLHdCQUF3QixLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQ3hHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QjtJQUNILENBQUM7SUFFRCxhQUFhO1FBQ1gsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQztRQUN4RCxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxRQUFRLENBQUMsYUFBYSxLQUFLLFdBQVcsRUFBRTtZQUNoRixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNwQixXQUFXLENBQUMsY0FBYyxDQUFDLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQztTQUNyRTtJQUNILENBQUM7SUFFRCx5QkFBeUI7UUFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELFNBQVMsQ0FBQyxLQUFvQjtRQUM1QiwyQ0FBMkM7UUFDM0Msd0NBQXdDO1FBQ3hDLHNFQUFzRTtRQUN0RSwyRkFBMkY7UUFDM0YscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFN0Isd0VBQXdFO1FBQ3hFLFFBQVEsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMvQixLQUFLLFFBQVEsQ0FBQyxPQUFPO2dCQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzlDLE1BQU07WUFDUixLQUFLLFFBQVEsQ0FBQyxTQUFTO2dCQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzlDLE1BQU07WUFDUixLQUFLLFFBQVEsQ0FBQyxVQUFVO2dCQUN0QixJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztnQkFDL0IsTUFBTTtZQUNSLEtBQUssUUFBUSxDQUFDLFNBQVM7Z0JBQ3JCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2dCQUM3QixNQUFNO1lBQ1IsS0FBSyxRQUFRLENBQUMsSUFBSTtnQkFDaEIsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO2dCQUN2QixJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFLENBQUM7Z0JBQzFDLE1BQU07WUFDUixLQUFLLFFBQVEsQ0FBQyxHQUFHO2dCQUNmLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO2dCQUN6QyxNQUFNO1lBQ1IsS0FBSyxRQUFRLENBQUMsS0FBSztnQkFDakIsSUFBSSxDQUFDLDRCQUE0QixFQUFFLENBQUM7Z0JBQ3BDLE1BQU07WUFDUixLQUFLLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFDcEIsS0FBSyxRQUFRLENBQUMsUUFBUTtnQkFDcEIsMERBQTBEO2dCQUMxRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO2dCQUNwQyxNQUFNO1lBQ1I7Z0JBQ0UsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSx5QkFBeUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDL0QsSUFBSSxDQUFDLGtCQUFrQixJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUM7b0JBQ3JDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7b0JBQ3JELE9BQU87aUJBQ1I7Z0JBQ0QsTUFBTTtTQUNUO1FBRUQsNENBQTRDO1FBQzVDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQVksUUFBUTtRQUNsQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVPLDRCQUE0QjtRQUNsQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRTtZQUMvQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDOUM7YUFBTTtZQUNMLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQzdCO0lBQ0gsQ0FBQztJQUVPLHVCQUF1QjtRQUM3QixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsK0VBQStFO1lBQy9FLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDakIsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQy9DO1NBQ0Y7YUFBTTtZQUNMLHdGQUF3RjtZQUN4Rix5RUFBeUU7WUFDekUsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQzthQUNwQztTQUNGO0lBQ0gsQ0FBQztJQUVPLHFCQUFxQjtRQUMzQixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1NBQ3JDO2FBQU07WUFDTCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDNUM7SUFDSCxDQUFDO0lBRU8sb0JBQW9CO1FBQzFCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQzlCO2FBQU07WUFDTCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN6RDtTQUNGO0lBQ0gsQ0FBQzs7d0dBdlJVLFdBQVcsa0JBVVosU0FBUyxhQUNULFdBQVcsYUFHWCxXQUFXOzRGQWRWLFdBQVcsK1RBbEJYO1FBQ1Qsa0JBQWtCO1FBQ2xCLHNCQUFzQjtRQUN0QixlQUFlO1FBQ2YsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUU7S0FDM0QsMkRBdUtnQixlQUFlLDhIQXJETyxVQUFVLDJDQzVLbkQsbzNFQWlFQSxvUkROYztRQUNWLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRTtZQUM1QixVQUFVLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRyxVQUFVLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRyxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDbEUsS0FBSyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN6QyxDQUFDO0tBQ0g7MkZBS1UsV0FBVztrQkFyQnZCLFNBQVM7K0JBQ0UsZUFBZSxhQUVkO3dCQUNULGtCQUFrQjt3QkFDbEIsc0JBQXNCO3dCQUN0QixlQUFlO3dCQUNmLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFO3FCQUMzRCxjQUNXO3dCQUNWLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRTs0QkFDNUIsVUFBVSxDQUFDLHVCQUF1QixFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ2pHLFVBQVUsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUNqRyxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7NEJBQ2xFLEtBQUssQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7eUJBQ3pDLENBQUM7cUJBQ0gsUUFDSzt3QkFDSix1QkFBdUIsRUFBRSxNQUFNO3FCQUNoQzs7MEJBWUUsTUFBTTsyQkFBQyxTQUFTOzswQkFDaEIsTUFBTTsyQkFBQyxXQUFXOzhCQUdYLFdBQVc7MEJBRmxCLFFBQVE7OzBCQUNSLFFBQVE7OzBCQUVSLFFBQVE7OzBCQUFJLElBQUk7K01BdUNmLFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxhQUFhO2dCQXNCUyxjQUFjO3NCQUExQyxNQUFNO3VCQUFDLG1CQUFtQjtnQkFRSCxVQUFVO3NCQUFqQyxLQUFLO3VCQUFDLGVBQWU7Z0JBTWxCLFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxhQUFhO2dCQVFTLGNBQWM7c0JBQTFDLE1BQU07dUJBQUMsbUJBQW1CO2dCQU1uQixnQkFBZ0I7c0JBRHZCLFNBQVM7dUJBQUMsa0JBQWtCLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBc0R6RCxnQkFBZ0I7c0JBRHZCLGVBQWU7dUJBQUMsZUFBZSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMiBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgYW5pbWF0ZSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIEluamVjdG9yLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFBMQVRGT1JNX0lELFxuICBRdWVyeUxpc3QsXG4gIFNlbGYsXG4gIFNraXBTZWxmLFxuICBWaWV3Q2hpbGQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgSWZFeHBhbmRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtZXhwYW5kZWQuc2VydmljZSc7XG5pbXBvcnQgeyBLZXlDb2RlcyB9IGZyb20gJy4uLy4uL3V0aWxzL2VudW1zL2tleS1jb2Rlcy5lbnVtJztcbmltcG9ydCB7IGlzS2V5RWl0aGVyTGV0dGVyT3JOdW1iZXIsIGtleVZhbGlkYXRvciwgcHJldmVudEFycm93S2V5U2Nyb2xsIH0gZnJvbSAnLi4vLi4vdXRpbHMvZm9jdXMva2V5LWZvY3VzL3V0aWwnO1xuaW1wb3J0IHsgRm9yVHlwZUFoZWFkUHJvdmlkZXIgfSBmcm9tICcuLi8uLi91dGlscy9mb3ItdHlwZS1haGVhZC9mb3ItdHlwZS1haGVhZC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy9kZWNsYXJhdGl2ZS10cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQ2xyU2VsZWN0ZWRTdGF0ZSB9IGZyb20gJy4vbW9kZWxzL3NlbGVjdGVkLXN0YXRlLmVudW0nO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBUUkVFX0ZFQVRVUkVTX1BST1ZJREVSLCBUcmVlRmVhdHVyZXNTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUZvY3VzTWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZm9jdXMtbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRyZWVOb2RlTGluayB9IGZyb20gJy4vdHJlZS1ub2RlLWxpbmsnO1xuXG5jb25zdCBMVklFV19DT05URVhUX0lOREVYID0gODtcblxuLy8gSWYgdGhlIHVzZXIgdHlwZXMgbXVsdGlwbGUga2V5cyB3aXRob3V0IGFsbG93aW5nIDIwMG1zIHRvIHBhc3MgYmV0d2VlbiB0aGVtLFxuLy8gdGhlbiB0aG9zZSBrZXlzIGFyZSBzZW50IHRvZ2V0aGVyIGluIG9uZSByZXF1ZXN0LlxuY29uc3QgVFJFRV9UWVBFX0FIRUFEX1RJTUVPVVQgPSAyMDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10cmVlLW5vZGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vdHJlZS1ub2RlLmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBVTklRVUVfSURfUFJPVklERVIsXG4gICAgVFJFRV9GRUFUVVJFU19QUk9WSURFUixcbiAgICBJZkV4cGFuZFNlcnZpY2UsXG4gICAgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBJZkV4cGFuZFNlcnZpY2UgfSxcbiAgXSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ3RvZ2dsZUNoaWxkcmVuQW5pbScsIFtcbiAgICAgIHRyYW5zaXRpb24oJ2NvbGxhcHNlZCA9PiBleHBhbmRlZCcsIFtzdHlsZSh7IGhlaWdodDogMCB9KSwgYW5pbWF0ZSgyMDAsIHN0eWxlKHsgaGVpZ2h0OiAnKicgfSkpXSksXG4gICAgICB0cmFuc2l0aW9uKCdleHBhbmRlZCA9PiBjb2xsYXBzZWQnLCBbc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSwgYW5pbWF0ZSgyMDAsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKV0pLFxuICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAndmlzaWJsZScgfSkpLFxuICAgICAgc3RhdGUoJ2NvbGxhcHNlZCcsIHN0eWxlKHsgaGVpZ2h0OiAwIH0pKSxcbiAgICBdKSxcbiAgXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLXRyZWUtbm9kZV0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRyZWVOb2RlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBTVEFURVMgPSBDbHJTZWxlY3RlZFN0YXRlO1xuICBwcml2YXRlIHNraXBFbWl0Q2hhbmdlID0gZmFsc2U7XG4gIGlzTW9kZWxMb2FkaW5nID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSB0eXBlQWhlYWRLZXlFdmVudDogU3ViamVjdDxzdHJpbmc+ID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG4gIHByaXZhdGUgdHlwZUFoZWFkS2V5QnVmZmVyID0gJyc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBub2RlSWQ6IHN0cmluZyxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IGFueSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcGFyZW50OiBDbHJUcmVlTm9kZTxUPixcbiAgICBAT3B0aW9uYWwoKSBAU2VsZigpIHByaXZhdGUgZm9yVHlwZUFoZWFkUHJvdmlkZXI6IEZvclR5cGVBaGVhZFByb3ZpZGVyLFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHVibGljIGV4cGFuZFNlcnZpY2U6IElmRXhwYW5kU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBmb2N1c01hbmFnZXI6IFRyZWVGb2N1c01hbmFnZXJTZXJ2aWNlPFQ+LFxuICAgIGluamVjdG9yOiBJbmplY3RvclxuICApIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uKSB7XG4gICAgICAvLyBJJ20gY29tcGxldGVseSBzdHVjaywgd2UgaGF2ZSB0byBoYWNrIGludG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIHVudGlsIGVpdGhlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTQ5MzUgb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU5OThcbiAgICAgIC8vIGFyZSBmaXhlZFxuICAgICAgLy8gVGhpcyBpcyBmb3Igbm9uLWl2eSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgIGlmICgoaW5qZWN0b3IgYXMgYW55KS52aWV3KSB7XG4gICAgICAgIHRoaXMuX21vZGVsID0gKGluamVjdG9yIGFzIGFueSkudmlldy5jb250ZXh0LmNsck1vZGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXZ5IHB1dHMgdGhpcyBvbiBhIHNwZWNpZmljIGluZGV4IG9mIGEgX2xWaWV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX21vZGVsID0gKGluamVjdG9yIGFzIGFueSkuX2xWaWV3W0xWSUVXX0NPTlRFWFRfSU5ERVhdLmNsck1vZGVsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JjZSBjYXN0IGZvciBub3csIG5vdCBzdXJlIGhvdyB0byB0aWUgdGhlIGNvcnJlY3QgdHlwZSBoZXJlIHRvIGZlYXR1cmVzU2VydmljZS5yZWN1cnNpb25cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbChwYXJlbnQgPyAocGFyZW50Ll9tb2RlbCBhcyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4pIDogbnVsbCk7XG4gICAgfVxuICAgIHRoaXMuX21vZGVsLm5vZGVJZCA9IHRoaXMubm9kZUlkO1xuICB9XG5cbiAgX21vZGVsOiBUcmVlTm9kZU1vZGVsPFQ+O1xuXG4gIGlzRXhwYW5kYWJsZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZXhwYW5kYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGU7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRhYmxlIHx8IHRoaXMuaXNQYXJlbnQ7XG4gIH1cblxuICBpc1NlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGU7XG4gIH1cblxuICBASW5wdXQoJ2NsclNlbGVjdGVkJylcbiAgZ2V0IHNlbGVjdGVkKCk6IENsclNlbGVjdGVkU3RhdGUgfCBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWU7XG4gIH1cbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBDbHJTZWxlY3RlZFN0YXRlIHwgYm9vbGVhbikge1xuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGZhbHN5IHN0YXRlcyBsaWtlIG51bGwgb3IgdW5kZWZpbmVkIGJlY2F1c2UgaXQncyBqdXN0IGVhc2llciB0aGFuIGFuc3dlcmluZyBxdWVzdGlvbnMuXG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHdpdGggc3RyaWN0IHR5cGluZyBvbiB0aGUgYXBwJ3Mgc2lkZSwgYnV0IGl0J3Mgbm90IHVwIHRvIHVzLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YWx1ZSA9IENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2ggYm9vbGVhbnMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgQ2xyU2VsZWN0ZWRTdGF0ZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA/IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBDbHJTZWxlY3RlZFN0YXRlLlVOU0VMRUNURUQ7XG4gICAgfVxuICAgIC8vIFdlIHByb3BhZ2F0ZSBvbmx5IGlmIHRoZSB0cmVlIGlzIGluIHNtYXJ0IG1vZGUsIGFuZCBza2lwIGVtaXR0aW5nIHRoZSBvdXRwdXQgd2hlbiB3ZSBzZXQgdGhlIGlucHV0XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMzA3M1xuICAgIHRoaXMuc2tpcEVtaXRDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX21vZGVsLnNldFNlbGVjdGVkKHZhbHVlLCB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciwgdGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIpO1xuICAgIHRoaXMuc2tpcEVtaXRDaGFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclNlbGVjdGVkQ2hhbmdlJykgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsclNlbGVjdGVkU3RhdGU+KGZhbHNlKTtcblxuICBnZXQgYXJpYVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU2VsZWN0YWJsZSgpID8gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWUgPT09IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBudWxsO1xuICB9XG5cbiAgLy8gQWxsb3dzIHRoZSBjb25zdW1lciB0byBvdmVycmlkZSBvdXIgbG9naWMgZGVjaWRpbmcgaWYgYSBub2RlIGlzIGV4cGFuZGFibGUuXG4gIC8vIFVzZWZ1bCBmb3IgcmVjdXJzaXZlIHRyZWVzIHRoYXQgZG9uJ3Qgd2FudCB0byBwcmUtbG9hZCBvbmUgbGV2ZWwgYWhlYWQganVzdCB0byBrbm93IHdoaWNoIG5vZGVzIGFyZSBleHBhbmRhYmxlLlxuICBASW5wdXQoJ2NsckV4cGFuZGFibGUnKSBleHBhbmRhYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gIC8vIEknbSBjYXZpbmcgb24gdGhpcywgZm9yIHRyZWUgbm9kZXMgSSB0aGluayB3ZSBjYW4gdG9sZXJhdGUgaGF2aW5nIGEgdHdvLXdheSBiaW5kaW5nIG9uIHRoZSBjb21wb25lbnRcbiAgLy8gcmF0aGVyIHRoYW4gZW5mb3JjZSB0aGUgY2xySWZFeHBhbmRlZCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBmb3IgZHluYW1pYyBjYXNlcy4gTW9zdGx5IGJlY2F1c2UgZm9yIHRoZSBzbWFydFxuICAvLyBjYXNlLCB5b3UgY2FuJ3QgdXNlIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUsIGl0IHdvdWxkIG5lZWQgdG8gZ28gb24gYW4gbmctY29udGFpbmVyLlxuICBASW5wdXQoJ2NsckV4cGFuZGVkJylcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQ7XG4gIH1cbiAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGVkID0gdmFsdWU7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb250ZW50Q29udGFpbmVyVGFiaW5kZXggPSAtMTtcbiAgQFZpZXdDaGlsZCgnY29udGVudENvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiB0cnVlIH0pXG4gIHByaXZhdGUgY29udGVudENvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9tb2RlbC5leHBhbmRlZCA9IHRoaXMuZXhwYW5kZWQ7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9tb2RlbC5zZWxlY3RlZC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5za2lwRW1pdENoYW5nZSkpLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX21vZGVsLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c1JlcXVlc3Quc3Vic2NyaWJlKG5vZGVJZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVJZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyZWVOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKG5vZGVJZCA9PiB7XG4gICAgICAgIHRoaXMuY2hlY2tUYWJJbmRleChub2RlSWQpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9tb2RlbC5sb2FkaW5nJC5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKGlzTG9hZGluZyA9PiAodGhpcy5pc01vZGVsTG9hZGluZyA9IGlzTG9hZGluZykpXG4gICAgKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAodGhpcy5mb3JUeXBlQWhlYWRQcm92aWRlcikge1xuICAgICAgdGhpcy5fbW9kZWwudGV4dENvbnRlbnQgPSB0aGlzLmZvclR5cGVBaGVhZFByb3ZpZGVyLnRleHRDb250ZW50O1xuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy50eXBlQWhlYWRLZXlFdmVudC5waXBlKGRlYm91bmNlVGltZShUUkVFX1RZUEVfQUhFQURfVElNRU9VVCkpLnN1YnNjcmliZSgoYnVmZmVyZWRLZXlzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c05vZGVTdGFydHNXaXRoKGJ1ZmZlcmVkS2V5cywgdGhpcy5fbW9kZWwpO1xuICAgICAgICAgIC8vIHJlc2V0IG9uY2UgYnVmZmVyZWRLZXlzIGFyZSB1c2VkXG4gICAgICAgICAgdGhpcy50eXBlQWhlYWRLZXlCdWZmZXIgPSAnJztcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fbW9kZWwuZGVzdHJveSgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvLyBAQ29udGVudENoaWxkIHdvdWxkIGhhdmUgYmVlbiBtb3JlIHN1Y2NpbmN0XG4gIC8vIGJ1dCBpdCBkb2Vzbid0IG9mZmVyIGEgd2F5IHRvIHF1ZXJ5IG9ubHkgYW4gaW1tZWRpYXRlIGNoaWxkXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyVHJlZU5vZGVMaW5rLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICBwcml2YXRlIHRyZWVOb2RlTGlua0xpc3Q6IFF1ZXJ5TGlzdDxDbHJUcmVlTm9kZUxpbms+O1xuXG4gIGdldCB0cmVlTm9kZUxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZU5vZGVMaW5rTGlzdCAmJiB0aGlzLnRyZWVOb2RlTGlua0xpc3QuZmlyc3Q7XG4gIH1cblxuICBwcml2YXRlIHNldFRhYkluZGV4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmNvbnRlbnRDb250YWluZXJUYWJpbmRleCA9IHZhbHVlO1xuICAgIHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrVGFiSW5kZXgobm9kZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLm5vZGVJZCAhPT0gbm9kZUlkICYmIHRoaXMuY29udGVudENvbnRhaW5lclRhYmluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5zZXRUYWJJbmRleCgtMSk7XG4gICAgfVxuICB9XG5cbiAgZm9jdXNUcmVlTm9kZSgpOiB2b2lkIHtcbiAgICBjb25zdCBjb250YWluZXJFbCA9IHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGNvbnRhaW5lckVsKSB7XG4gICAgICB0aGlzLnNldFRhYkluZGV4KDApO1xuICAgICAgY29udGFpbmVyRWwuZm9jdXMoKTtcbiAgICAgIGNvbnRhaW5lckVsLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICduZWFyZXN0JywgaW5saW5lOiAnbmVhcmVzdCcgfSk7XG4gICAgfVxuICB9XG5cbiAgYnJvYWRjYXN0Rm9jdXNPbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLmZvY3VzTWFuYWdlci5icm9hZGNhc3RGb2N1c2VkTm9kZSh0aGlzLm5vZGVJZCk7XG4gIH1cblxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBUd28gcmVhc29ucyB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3I6XG4gICAgLy8gMS4gdG8gcHJldmVudCBzY3JvbGxpbmcgb24gYXJyb3cga2V5c1xuICAgIC8vIDIuIEFzc2lzdGl2ZSBUZWNobm9sb2d5IGZvY3VzIGRpZmZlcnMgZnJvbSBLZXlib2FyZCBmb2N1cyBiZWhhdmlvci5cbiAgICAvLyAgICBCeSBkZWZhdWx0LCBwcmVzc2luZyBhcnJvdyBrZXkgbWFrZXMgQVQgZm9jdXMgZ28gaW50byB0aGUgbmVzdGVkIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAgcHJldmVudEFycm93S2V5U2Nyb2xsKGV2ZW50KTtcblxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMtMS4xLyNrZXlib2FyZC1pbnRlcmFjdGlvbi0yMlxuICAgIHN3aXRjaCAoa2V5VmFsaWRhdG9yKGV2ZW50LmtleSkpIHtcbiAgICAgIGNhc2UgS2V5Q29kZXMuQXJyb3dVcDpcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNOb2RlQWJvdmUodGhpcy5fbW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5Q29kZXMuQXJyb3dEb3duOlxuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c05vZGVCZWxvdyh0aGlzLl9tb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5BcnJvd1JpZ2h0OlxuICAgICAgICB0aGlzLmV4cGFuZE9yRm9jdXNGaXJzdENoaWxkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5BcnJvd0xlZnQ6XG4gICAgICAgIHRoaXMuY29sbGFwc2VPckZvY3VzUGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlDb2Rlcy5Ib21lOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLkVuZDpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNMYXN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLkVudGVyOlxuICAgICAgICB0aGlzLnRvZ2dsZUV4cGFuZE9yVHJpZ2dlckRlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleUNvZGVzLlNwYWNlOlxuICAgICAgY2FzZSBLZXlDb2Rlcy5TcGFjZWJhcjpcbiAgICAgICAgLy8gdG8gcHJldmVudCBzY3JvbGxpbmcgb24gc3BhY2Uga2V5IGluIHRoaXMgc3BlY2lmaWMgY2FzZVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnRvZ2dsZUV4cGFuZE9yVHJpZ2dlckRlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5fbW9kZWwudGV4dENvbnRlbnQgJiYgaXNLZXlFaXRoZXJMZXR0ZXJPck51bWJlcihldmVudCkpIHtcbiAgICAgICAgICB0aGlzLnR5cGVBaGVhZEtleUJ1ZmZlciArPSBldmVudC5rZXk7XG4gICAgICAgICAgdGhpcy50eXBlQWhlYWRLZXlFdmVudC5uZXh0KHRoaXMudHlwZUFoZWFkS2V5QnVmZmVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gaWYgbm9uLWxldHRlciBrZXlzIGFyZSBwcmVzc2VkLCBkbyByZXNldC5cbiAgICB0aGlzLnR5cGVBaGVhZEtleUJ1ZmZlciA9ICcnO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNQYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmNoaWxkcmVuICYmIHRoaXMuX21vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIH1cblxuICBwcml2YXRlIHRvZ2dsZUV4cGFuZE9yVHJpZ2dlckRlZmF1bHQoKSB7XG4gICAgaWYgKHRoaXMuaXNFeHBhbmRhYmxlKCkgJiYgIXRoaXMuaXNTZWxlY3RhYmxlKCkpIHtcbiAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyaWdnZXJEZWZhdWx0QWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBleHBhbmRPckZvY3VzRmlyc3RDaGlsZCgpIHtcbiAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYWxyZWFkeSBleHBhbmRlZCBhbmQgaGFzIGNoaWxkcmVuLCBmb2N1cyBpdHMgdmVyeSBmaXJzdCBjaGlsZFxuICAgICAgaWYgKHRoaXMuaXNQYXJlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNOb2RlQmVsb3codGhpcy5fbW9kZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBtdXN0IGNoZWNrIGlmIHRoZSBub2RlIGlzIGV4cGFuZGFibGUsIGluIG9yZGVyIHRvIHNldCAuZXhwYW5kZWQgdG8gdHJ1ZSBmcm9tIGZhbHNlXG4gICAgICAvLyBiZWNhdXNlIHdlIHNob3VsZG4ndCBzZXQgLmV4cGFuZGVkIHRvIHRydWUgaWYgaXQncyBub3QgZXhwYW5kYWJsZSBub2RlXG4gICAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUoKSkge1xuICAgICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29sbGFwc2VPckZvY3VzUGFyZW50KCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNQYXJlbnQodGhpcy5fbW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlckRlZmF1bHRBY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudHJlZU5vZGVMaW5rKSB7XG4gICAgICB0aGlzLnRyZWVOb2RlTGluay5hY3RpdmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pc1NlbGVjdGFibGUoKSkge1xuICAgICAgICB0aGlzLl9tb2RlbC50b2dnbGVTZWxlY3Rpb24odGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiPCEtLVxuICB+IENvcHlyaWdodCAoYykgMjAxNi0yMDIxIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICB+IFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gIH4gVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICAtLT5cblxuPGRpdlxuICAjY29udGVudENvbnRhaW5lclxuICByb2xlPVwidHJlZWl0ZW1cIlxuICBjbGFzcz1cImNsci10cmVlLW5vZGUtY29udGVudC1jb250YWluZXJcIlxuICB0YWJpbmRleD1cIi0xXCJcbiAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJpc0V4cGFuZGFibGUoKSA/IGV4cGFuZGVkIDogbnVsbFwiXG4gIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiYXJpYVNlbGVjdGVkXCJcbiAgKGtleWRvd24pPVwib25LZXlEb3duKCRldmVudClcIlxuICAoZm9jdXMpPVwiYnJvYWRjYXN0Rm9jdXNPbkNvbnRhaW5lcigpXCJcbj5cbiAgPGJ1dHRvblxuICAgICpuZ0lmPVwiaXNFeHBhbmRhYmxlKCkgJiYgIWlzTW9kZWxMb2FkaW5nICYmICFleHBhbmRTZXJ2aWNlLmxvYWRpbmdcIlxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgdHlwZT1cImJ1dHRvblwiXG4gICAgdGFiaW5kZXg9XCItMVwiXG4gICAgY2xhc3M9XCJjbHItdHJlZW5vZGUtY2FyZXRcIlxuICAgIChjbGljayk9XCJleHBhbmRTZXJ2aWNlLnRvZ2dsZSgpO1wiXG4gICAgKGZvY3VzKT1cImZvY3VzVHJlZU5vZGUoKVwiXG4gID5cbiAgICA8Y2RzLWljb25cbiAgICAgIGNsYXNzPVwiY2xyLXRyZWVub2RlLWNhcmV0LWljb25cIlxuICAgICAgc2hhcGU9XCJhbmdsZVwiXG4gICAgICBbYXR0ci5kaXJlY3Rpb25dPVwiZXhwYW5kU2VydmljZS5leHBhbmRlZCA/ICdkb3duJyA6ICdyaWdodCdcIlxuICAgID48L2Nkcy1pY29uPlxuICA8L2J1dHRvbj5cbiAgPGRpdiBjbGFzcz1cImNsci10cmVlbm9kZS1zcGlubmVyLWNvbnRhaW5lclwiICpuZ0lmPVwiZXhwYW5kU2VydmljZS5sb2FkaW5nIHx8IGlzTW9kZWxMb2FkaW5nXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJjbHItdHJlZW5vZGUtc3Bpbm5lciBzcGlubmVyXCI+PC9zcGFuPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImNsci1jaGVja2JveC13cmFwcGVyIGNsci10cmVlbm9kZS1jaGVja2JveFwiICpuZ0lmPVwiZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGVcIj5cbiAgICA8aW5wdXRcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgaWQ9XCJ7e25vZGVJZH19LWNoZWNrXCJcbiAgICAgIGNsYXNzPVwiY2xyLWNoZWNrYm94XCJcbiAgICAgIFtjaGVja2VkXT1cIl9tb2RlbC5zZWxlY3RlZC52YWx1ZSA9PT0gU1RBVEVTLlNFTEVDVEVEXCJcbiAgICAgIFtpbmRldGVybWluYXRlXT1cIl9tb2RlbC5zZWxlY3RlZC52YWx1ZSA9PT0gU1RBVEVTLklOREVURVJNSU5BVEVcIlxuICAgICAgKGNoYW5nZSk9XCJfbW9kZWwudG9nZ2xlU2VsZWN0aW9uKGZlYXR1cmVzU2VydmljZS5lYWdlcilcIlxuICAgICAgKGZvY3VzKT1cImZvY3VzVHJlZU5vZGUoKVwiXG4gICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAvPlxuICAgIDxsYWJlbCBmb3I9XCJ7e25vZGVJZH19LWNoZWNrXCIgY2xhc3M9XCJjbHItY29udHJvbC1sYWJlbFwiPjwvbGFiZWw+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY2xyLXRyZWVub2RlLWNvbnRlbnRcIiAobW91c2Vkb3duKT1cImZvY3VzVHJlZU5vZGUoKVwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLXNyLW9ubHlcIiAqbmdJZj1cImZlYXR1cmVzU2VydmljZS5zZWxlY3RhYmxlXCI+XG4gICAgICA8c3BhbiAqbmdJZj1cImFyaWFTZWxlY3RlZFwiPnNlbGVjdGVkPC9zcGFuPlxuICAgICAgPHNwYW4gKm5nSWY9XCIhYXJpYVNlbGVjdGVkXCI+dW5zZWxlY3RlZDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbjxkaXZcbiAgY2xhc3M9XCJjbHItdHJlZW5vZGUtY2hpbGRyZW5cIlxuICBbQHRvZ2dsZUNoaWxkcmVuQW5pbV09XCJleHBhbmRTZXJ2aWNlLmV4cGFuZGVkID8gJ2V4cGFuZGVkJyA6ICdjb2xsYXBzZWQnXCJcbiAgW2F0dHIucm9sZV09XCJpc0V4cGFuZGFibGUoKSAmJiAhZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbiA/ICdncm91cCcgOiBudWxsXCJcbj5cbiAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXRyZWUtbm9kZVwiPjwvbmctY29udGVudD5cbiAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NscklmRXhwYW5kZWRdXCI+PC9uZy1jb250ZW50PlxuICA8Y2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbiBbcGFyZW50XT1cIl9tb2RlbFwiPjwvY2xyLXJlY3Vyc2l2ZS1jaGlsZHJlbj5cbjwvZGl2PlxuIl19